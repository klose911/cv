#+TITLE: 取消和关闭
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="css/org.css" />
#+OPTIONS: num:nil
* 任务取消
启动任务之后, 大多数时候我们等待运行完成，但是有时我们希望可以提前终止任务的运行:
1. 用户申请取消时，比如用户点击了取消按钮.
2. 时间限制的任务，有些任务具有时间限制, 如果在一定的时间内仍然没有得到想要的结果, 可能希望终止该任务的运行.
3. 发生特定的事件时，比如多个任务同时在不同的位置搜索某一文件, 当其中一个搜索到了想要的文件, 应该终止其他仍在运行的任务
4. 发生错误时，比如发生了磁盘已满的错误, 需要向磁盘写入数据的任务应该提前终止
5. 应用或者服务被关闭时

** 设置自定义flag结束线程
   #+BEGIN_SRC java
     public class PrimeGenerator implements Runnable {
             @GuardedBy("this")
             private final List<BigInteger> primes = new ArrayList<BigInteger>();

             //自定义的flag, 为保证线程可见性, 将其声明为volatile 
             private volatile boolean cancelled;

             @Override
             public void run() {
                     BigInteger p = BigInteger.ONE;
                     // 每次循环之前检查cancelled标记的值, 如果cancelled为true, 循环终止, 线程也就运行结束了 
                     while (!cancelled) {
                             p = p.nextProbablePrime();
                             synchronized (this) {
                                     primes.add(p);
                             }
                     }
             }

             public void cancel() {
                     cancelled = true;
             }

             public synchronized List<BigInteger> get() {
                     return new ArrayList<>(primes);
             }
     }

   #+END_SRC

测试代码
   #+BEGIN_SRC java
     public static void main(String[] args) {
             PrimeGenerator generator = new PrimeGenerator();
             Thread t = new Thread(generator);
             t.start();
                  
             try {
                     Thread.sleep(1000);
             } catch (InterruptedException e) {
                     //除非明确知道主线程应该终止，不然通常情况下应该重新抛出InterruptedException或者恢复被中断的线程
             }
             // 通过调用cancel方法, 将自定义的cancelled标记设置为true, 从而使得线程t运行终止  
             generator.cancel();
             System.out.println(generator.get().size());
     }
   #+END_SRC

*** 自定义flag的问题
假如循环中执行了阻塞操作, 那么即使cancelled标记被设置为true, run方法却没有机会去检查cancelled标记的值, 线程将迟迟无法结束！　
#+BEGIN_SRC java
  class BrokenPrimeProducer extends Thread {
          private final BlockingQueue<BigInteger> queue;
          private volatile boolean cancelled = false;
          BrokenPrimeProducer(BlockingQueue<BigInteger> queue) {
                  this.queue = queue;
          }
          public void run() {
                  try {
                          BigInteger p = BigInteger.ONE;
                          while (!cancelled)
                                  // 当队列已满时, put方法将会阻塞. 一旦put方法阻塞
                                  //且没有其他线程从队列中取数据时, 阻塞将一直持续下去  
                                  queue.put(p = p.nextProbablePrime());
                  } catch (InterruptedException consumed) { }
          }
          public void cancel() { cancelled = true; }
  }
#+END_SRC

测试代码
#+BEGIN_SRC java
  public static void main(String[] args) {  
          // 设置队列的最大容量为10  
          BlockingQueue<BigInteger> primes = new LinkedBlockingQueue<BigInteger>(10);  
          BrokenPrimeProducer producer = new BrokenPrimeProducer(primes);  
          producer.start();  
            
          try {  
                  Thread.sleep(1000);  
          } catch (InterruptedException e) {
          }  
          producer.cancel();  
  }  
#+END_SRC

** 中断
java没有直接规定如何安全的提前终止线程的运行, 而是提供了不具约束力的协商式机制: 线程A可以请求线程B中断, 但是是否响应, 何时响应, 如何响应中断请求, 由线程B自己决定　\\
每个线程对象都有一个boolean型的中断标记, 其他线程请求目标线程中断时, 会将目标线程的中断标记设置为true, 然后由目标线程自己决定如何处理。所以中断线程时, 需要明确知道目标线程的中断机制, 如果不知道目标线程会怎样处理中断请求, 不要贸然请求其中断

Thread类中与中断标记相关的方法有:
#+BEGIN_SRC java
  public class Thread {   
          // 请求线程中断, 该方法会将线程的中断标记设置为true. 如何处理中断由目标线程决定  
          public void interrupt() { ... }   
          // 返回中断标记的值  
          public boolean isInterrupted() { ... }  
          // 静态方法用于重置当前进程的中断标记(将其设置为false), 并返回重置之前的值  
          public static boolean interrupted() { ... }   
          ...   
  }  
#+END_SRC

*** 可中断的阻塞方法
java API中的大多数阻塞方法都是可中断的, 如Thread.sleep, Object.wait, BlockingQueue.put等 \\
可中断的阻塞方法有一个共同的特点: 声明抛出InterruptedException异常 \\
可中断的阻塞方法在阻塞期间会周期性检查当前线程的中断标记, 如果发现当前线程的中断标记为true, 就重置中断标记后提前从阻塞状态返回, 并抛出InterruptedException异常  

使用中断终止PrimeProducer

#+BEGIN_SRC java
  class PrimeProducer extends Thread {
          private final BlockingQueue<BigInteger> queue;
          
          PrimeProducer(BlockingQueue<BigInteger> queue) {
                  this.queue = queue;
          }

          public void run() {
                  try {
                          BigInteger p = BigInteger.ONE;
                          // 每次循环前检查当前线程的中断标记, 如果中断标记为设定为true, 则循环结束  
                          // 就算当前线程阻塞在put方法上, 在阻塞期间也会周期性检查中断标记, 
                          //一旦发现中断标记为true, 就会从阻塞状态中返回, 并抛出InterruptedException异常  
                          while (!Thread.currentThread().isInterrupted()) {
                                  queue.put(p = p.nextProbablePrime());
                          }
                  } catch (InterruptedException consumed) {
                          System.out.println("InterruptedException happened");
                  }
          }

          public void cancel() {
                  // interrupt方法会将当前线程的中断标记设置为true  
                  interrupt();
          }
  }
#+END_SRC

测试代码
#+BEGIN_SRC java
  public static void main(String[] args) {
          // 设置队列的最大容量为10  
          BlockingQueue<BigInteger> primes = new LinkedBlockingQueue<>(10);
          PrimeProducer producer = new PrimeProducer(primes);
          producer.start();

          try {
                  Thread.sleep(1000);
          } catch (InterruptedException e) {
          }
          //
          producer.cancel();
  }
#+END_SRC

** 处理InterruptedException
*** 不catch直接向上层抛出，或者catch住做一些清理工作之后重抛该异常
这样的处理使得你的方法也成为一个可中断的阻塞方法 

#+BEGIN_SRC java
  // 直接向上层抛出InterruptedException, dosomething方法也是一个可中断的阻塞方法  
  private void dosomething() throws InterruptedException {  
          Thread.sleep(1000);  
  }  
#+END_SRC
*** 不能向上抛出InterruptedException异常
catch之后, 必须设置当前线程的中断标记为true, 以表明当前线程发生了中断, 以便调用栈上层进行处理
#+BEGIN_SRC java
  public class InterruptedExceptionHandler implements Runnable {  
          private Object lock = new Object();  
    
          @Override  
          public void run() {
                  while (!Thread.currentThread().isInterrupted()) {  
                          dosomething();  
                  }  
          }  
    
          private void dosomething() {  
                  try {  
                          // Object.wait是一个可中断的阻塞方法
                          // 如果在其阻塞期间检查到当前线程的中断标记为true, 会重置中断标记后从阻塞状态返回, 并抛出InterruptedException异常  
                          synchronized (lock) {  
                                  lock.wait();  // 会重置中断标记后从阻塞状态返回, 并抛出InterruptedException异常 
                          }  
                  } catch (InterruptedException e) {  
                          System.out.println("InterruptedException happened");  
                          // catch住InterruptedException后设置当前线程的中断标记为true, 以供调用栈上层进行相应的处理  
                          // 在此例中, dosomething方法的调用栈上层是run方法.  
                          Thread.currentThread().interrupt();  
                  }  
          }  
        
          public static void main(String[] args) throws InterruptedException {  
                  Thread t = new Thread(new InterruptedExceptionHandler());  
                  t.start();  
                  Thread.sleep(1000);
                  // 启动线程1s后设置其中断标记为true
                  t.interrupt();  
          }  
  }  
#+END_SRC
主线程启动InterruptedExceptionHandler线程1s后, 设置InterruptedExceptionHandler线程的中断标记为true. 此时InterruptedExceptionHandler线程应该阻塞在wait方法上, 由于wait方法是可中断的阻塞方法, 所以其检查到中断标记为true时, 将重置当前线程的中断标记后抛出InterruptedException, dosomething方法catch住InterruptedException异常后, 再次将当前线程的中断标记设置为true, run方法检查到中断标记为true, 循环不再继续 \\
假如dosomething方法catch住InterruptedException异常后没有设置中断标记, 其调用栈上层的run方法就无法得知线程曾经发生过中断, 循环也就无法终止
*** 发生了InterruptedException异常后仍然继续循环执行某阻塞方法 
将中断状态保存下来, 当循环完成后再根据保存下来的中断状态执行相应的操作

#+BEGIN_SRC java
  public class InterruptedExceptionContinueHandler implements Runnable {
          private BlockingQueue<Integer> queue;

          public InterruptedExceptionContinueHandler(BlockingQueue<Integer> queue) {
                  this.queue = queue;
          }

          @Override
          public void run() {
                  while (!Thread.currentThread().isInterrupted()) {
                          dosomething();
                  }
                  System.out.println(queue.size());
          }

          private void dosomething() {
                  // cancelled变量用于表明线程是否发生过中断
                  boolean cancelled = false;
                  for (int i = 0; i < 10000; i++) {
                          try {
                                  queue.put(i);
                          } catch (InterruptedException e) {
                                  // 就算发生了InterruptedException, 循环也希望继续运行下去, 此时将cancelled设置为true, 以表明遍历过程中发生了中断
                                  System.out.println("InterruptedException happened when i = " + i);
                                  cancelled = true;
                          }
                  }
                  if (cancelled) {
                          // 如果当前线程曾经发生过中断, 就将其中断标记设置为true, 以通知dosomething方法的上层调用栈
                          Thread.currentThread().interrupt();
                  }
          }

          public static void main(String[] args) throws InterruptedException {
                  Thread t = new Thread(new InterruptedExceptionContinueHandler(new LinkedBlockingQueue<Integer>()));
                  t.start();

                  // 启动线程2ms后设置其中断标记为true
                  Thread.sleep(2);
                  t.interrupt();
          }
  }
#+END_SRC
等待doSomething的循环执行完毕，恢复中断状态为true，再run中处理中断

#+BEGIN_SRC java
  private void dosomething() {
          for (int i = 0; i < 10000; i++) {
                  try {
                          queue.put(i);
                  } catch (InterruptedException e) {
                          System.out.println("InterruptedException happened when i = " + i);
                          //过早重置中断状态为true会导致put方法又抛出InterruptedException异常, 如此往复直到循环结束.
                          Thread.currentThread().interrupt();
                  }
          }
  }
#+END_SRC
过早重置中断状态为true会导致put方法又抛出InterruptedException异常, 如此往复直到循环结束 
*** 忽略InterruptedException
只有当InterruptedException被捕获在调用栈的最上层, 如run方法, 或者main方法中, 且后续代码不检查中断状态时， 其他任何情况下都应该对InterruptedException作处理
** 限时运行

   #+BEGIN_SRC java
     private static final ScheduledExecutorService cancelExec = ...;
     public static void timedRun(Runnable r,
                                 long timeout, TimeUnit unit) {
             final Thread taskThread = Thread.currentThread();
             cancelExec.schedule(new Runnable() {
                             public void run() { taskThread.interrupt(); }
                     }, timeout, unit);
             r.run();
     }
   #+END_SRC
timeRun方法可以在任何一个线程中调用，所以timeRun方法无法知道运行线程处理中断的策略，不应该贸然向对应的线程发出中断请求
+ 在r.run运行完成后，调用线程捕获中断异常是危险的
+ 如果调用线程忽略了中断异常，那只有r.run运行完毕timeRun才能结束，这会超出所要求的运行时间

#+BEGIN_SRC java
  private static final ScheduledExecutorService cancelExec = Executors.newScheduledThreadPool(10);

  public static void timedRun(final Runnable r,
                              long timeout, TimeUnit unit) throws InterruptedException {

          class ReThrowableTask implements Runnable {
                  //在当前线程和taskThread线程共享异常
                  private volatile Throwable t;

                  public void run() {
                          try {
                                  r.run();
                          } catch (Throwable t) {
                                  this.t = t;
                          }
                  }

                  void rethrow() {
                          if (t != null)
                                  throw launderThrowable(t);
                  }
          }

          ReThrowableTask task = new ReThrowableTask();
          final Thread taskThread = new Thread(task);
          taskThread.start();
          cancelExec.schedule(new Runnable() {
                          public void run() {
                                  taskThread.interrupt();
                          }
                  }, timeout, unit);
          // 停止当前进程，让taskThread运行限时时间
          // 如果超过限时，则让cancelExec线程池的线程对taskThread发起中断请求
          taskThread.join(unit.toMillis(timeout));
          //如果taskThread线程内捕获异常，重新抛出
          task.rethrow();
  }
#+END_SRC
1. 创建taskThread线程，把运行任务包装到taskThread
2. 通过join方法让taskThread跑限时时间
3. 超过限时时间，向taskThread发送中断请求
4. 在taskThread中发现异常，则重新抛出供主线程处理

** 取消Future
