#+TITLE: 任务执行
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="css/org.css" />
#+OPTIONS: num:nil
* 线程中执行任务
** 串行执行
吞吐量低，响应慢，IO操作中浪费cpu

** 每个请求单独线程
1. 线程的创建和销毁会占用一定的资源。如果请求频繁而对请求的处理是轻量级的(大多的web请求符合该情形), 创建一个线程处理请求后将其销毁的方式是不划算的
2. 过多的线程导致线程切换频繁, 用于处理请求的CPU时间反而会减少. 如果当前的线程数已经让CPU处于忙碌状态, 那么增加更多的线程不会改善应用的性能 
3. 过多的线程会导致系统稳定性下降　

* Executor框架
将创建好的线程组织成线程池, 当请求来临时从池中取出线程处理请求, 处理完毕后将线程归还给线程池, 而不是销毁　\\
通过限制线程池中的线程数, 以克服线程过多时性能和稳定性下降的缺陷 \\

Executor框架包含多个线程池的实现, 所有线程池都派生自Executor接口\\
 　
Executor接口只定义了一个方法: execute(Runnable task) 
#+BEGIN_SRC java
  public interface Executor {
          void execute(Runnable command);
  }
#+END_SRC

Executor接口解耦了任务提交和任务执行, 提交任务的线程为生产者, 执行任务的线程为消费者 
#+BEGIN_SRC java
  class TaskExecutionWebServer {   
          private static final int NTHREADS = 100;   
          // 创建线程池  
          private static final Executor exec   
          = Executors.newFixedThreadPool(NTHREADS);   
     
          public static void main(String[] args) throws IOException {   
                  ServerSocket socket = new ServerSocket(80);   
                  while (true) {   
                          final Socket connection = socket.accept();   
                          Runnable task = new Runnable() {   
                                          public void run() {   
                                                  handleRequest(connection);   
                                          }   
                                  };   
                          // 将任务提交给线程池执行  
                          exec.execute(task);   
                  }   
          }   
  }  
#+END_SRC

使用Executor实现每个请求一个线程

#+BEGIN_SRC java
  public class ThreadPerTaskExecutor implements Executor {
          public void execute(Runnable r) {
                  new Thread(r).start();
          };
  }
#+END_SRC

** 线程执行策略
+ 任务在哪个线程中执行
+ 任务以何种顺序（FIFO, LIFO, 优先级）执行
+ 同时有多少线程同步执行任务
+ 多少任务可以等待执行
+ 当负荷过载时候，那些任务可以被牺牲，如何通知应用这些任务
+ 任务执行前和执行后需要哪些操作

** 线程池 
ExecutorService接口继承自Executor, 而预定义的线程池类大多实现了ExecutorService接口 
- newFixedThreadPool: 最大线程数固定的线程池.
- newCachedThreadPool: 可伸缩式线程池, 当线程池中线程的数量超过程序所需时, 会自动销毁多余的线程; 当线程池中的线程不能需要时再创建新的线程执行提交的任务, 该线程池没有最大线程数的限定
- newSingleThreadExecutor: 仅包含一个线程的线程池, 提交给该线程池执行的任务, 都将在这一单个线程中完成处理
- newScheduledThreadPool. 最大线程数固定且支持延迟和周期性重复执行任务的线程池

** Executor生命周期：运行，关闭中，终止

   #+BEGIN_SRC java
     public interface ExecutorService extends Executor {
             void shutdown();
             List<Runnable> shutdownNow();
             boolean isShutdown();
             boolean isTerminated();
             boolean awaitTermination(long timeout, TimeUnit unit)
                     throws InterruptedException;
     // ... additional convenience methods for task submission
     }
   #+END_SRC
- shutdown: 在关闭前允许执行以前提交的任务, 包括那些已提交但尚未开始执行的任务 
- shutdownNow: 阻止尚未开始执行的任务启动并试图停止当前正在执行的任务, 返回从未开始执行的任务的列表
- isShutdown：判断线程池是否已关闭. 线程池关闭后将拒绝接受新任务, 将抛出RejectedExecutionException
- awaitTermination: 将使得主线程阻塞, 直到线程池转变为终止状态, 通常在调用shutdown方法后紧接着调用awaitTermination方法
- isTerminated: 检测线程池是否处于终止状态, 当线程池已关闭, 并且所有提交给线程池的任务都已完成时, 线程池转变为终止状态


   #+BEGIN_SRC java
     class LifecycleWebServer {
             private final ExecutorService exec = ...;
             public void start() throws IOException {
                     ServerSocket socket = new ServerSocket(80);
                     while (!exec.isShutdown()) {
                             try {
                                     final Socket conn = socket.accept();
                                     exec.execute(new Runnable() {
                                                     public void run() { handleRequest(conn); }
                                             });
                             } catch (RejectedExecutionException e) {
                                     if (!exec.isShutdown())
                                             log("task submission rejected", e);
                             }
                     }
             }
             public void stop() { exec.shutdown(); }
             void handleRequest(Socket connection) {
                     Request req = readRequest(connection);
                     if (isShutdownRequest(req))
                             stop();
                     else
                             dispatchRequest(req);
             }
     }
   #+END_SRC

** Timer和ScheduledThreadPool 
两者都可以用于延时或周期性重复执行某个任务, 但是Timer存在一些缺陷:
1. Timer基于绝对时间来安排任务的调度, 因此系统时钟的改变会对其产生影响. ScheduledThreadPoolExecutor基于相对时间进行任务的调度
2. Timer创建单一的线程执行定时任务. 假如Timer对象以10ms的间隔重复执行某个任务, 但是其中的一次执行花去了40ms, 这就意味着少执行了至少4次重复任务. ScheduledThreadPoolExecutor可以使用多个线程执行定时任务
3. 如果在执行任务的过程中抛出运行时异常, Timer的线程会被终止且没有恢复机制
几乎没有理由继续使用Timer调度定时任务了

* 发现可利用的并发
